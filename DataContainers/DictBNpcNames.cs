using Dalamud.Game;
using Dalamud.Plugin;
using OtterGui;
using OtterGui.Log;
using Penumbra.GameData.Data;
using Penumbra.GameData.DataContainers.Bases;
using Penumbra.GameData.Structs;

namespace Penumbra.GameData.DataContainers;

/// <summary> A dictionary mapping a single BNpcBaseId to a list of BNpcNameIds, using the data generated by the Gubal API (cf. <see cref="NpcNames"/>). </summary>
public sealed class DictBNpcNames(IDalamudPluginInterface pluginInterface, Logger log)
    : DataSharer<IReadOnlyList<IReadOnlyList<uint>>>(pluginInterface, log, "BNpcNameDict", ClientLanguage.English, 4, NpcNames.CreateNames),
        IReadOnlyDictionary<BNpcId, IReadOnlyList<BNpcNameId>>
{

    /// <summary> Reverse-search all lists for all BNpcBaseIds associated with a name. </summary>
    public IReadOnlyList<BNpcId> GetBNpcsFromName(BNpcNameId bNpcNameId)
    {
        var list = new List<BNpcId>(8);
        foreach (var (names, bNpcId) in Value.WithIndex())
        {
            if (names.Contains(bNpcNameId.Id))
                list.Add((BNpcId)(uint)bNpcId);
        }

        return list;
    }

    /// <inheritdoc/>
    public IEnumerator<KeyValuePair<BNpcId, IReadOnlyList<BNpcNameId>>> GetEnumerator()
        => Value.Select((list, idx) => new KeyValuePair<BNpcId, IReadOnlyList<BNpcNameId>>((uint)idx, BNpcNameList.Create(list)))
            .GetEnumerator();

    /// <inheritdoc/>
    IEnumerator IEnumerable.GetEnumerator()
        => GetEnumerator();

    /// <inheritdoc/>
    public int Count
        => Value.Count;

    /// <inheritdoc/>
    public bool ContainsKey(BNpcId key)
        => key.Id < Count;

    /// <inheritdoc/>
    public bool TryGetValue(BNpcId key, out IReadOnlyList<BNpcNameId> value)
    {
        if (key.Id >= Count)
        {
            value = Array.Empty<BNpcNameId>();
            return false;
        }

        value = BNpcNameList.Create(Value[(int)key.Id]);
        return true;
    }

    /// <inheritdoc/>
    public IReadOnlyList<BNpcNameId> this[BNpcId key]
        => TryGetValue(key, out var value) ? value : Array.Empty<BNpcNameId>();

    /// <inheritdoc/>
    public IEnumerable<BNpcId> Keys
        => Enumerable.Range(0, Value.Count).Select(v => new BNpcId((uint)v));

    /// <inheritdoc/>
    public IEnumerable<IReadOnlyList<BNpcNameId>> Values
        => Value.Select(BNpcNameList.Create);

    /// <inheritdoc/>
    protected override long ComputeMemory()
        => 16 * (Count + 1) + TotalCount * 4;

    /// <inheritdoc/>
    protected override int ComputeTotalCount()
        => Value.Sum(l => l.Count);

    /// <summary> Wrapper around a uint-list turning it into a BNpcNameId list. </summary>
    private readonly struct BNpcNameList(IReadOnlyList<uint> items) : IReadOnlyList<BNpcNameId>
    {
        /// <summary> Use Array.Empty where possible. </summary>
        public static IReadOnlyList<BNpcNameId> Create(IReadOnlyList<uint> items)
            => items.Count > 0 ? new BNpcNameList(items) : Array.Empty<BNpcNameId>();

        /// <inheritdoc/>
        public IEnumerator<BNpcNameId> GetEnumerator()
            => items.Select(i => (BNpcNameId)i).GetEnumerator();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator()
            => GetEnumerator();

        /// <inheritdoc/>
        public int Count
            => items.Count;

        /// <inheritdoc/>
        public BNpcNameId this[int index]
            => items[index];
    }
}
